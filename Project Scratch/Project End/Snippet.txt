-----------------------------------------------------------------------------------------------------------------------------
1 . Fish AI
-----------------------------------------------------------------------------------------------------------------------------
let   raycaster = new THREE.Raycaster();
export let intersects;
export var barrel_r = false;
let mouse;



let fishCollectionCount = 0;

const Fishloader = new GLTFLoader();

Fishloader.load('model/TuneFish.glb',function(glb){
  const model = glb.scene;
  const clips = glb.animations;
  
  const fishes = new THREE.AnimationObjectGroup();
  mixer = new THREE.AnimationMixer(fishes);
  const clip = THREE.AnimationClip.findByName(clips,'TunaSwim');
  const action = mixer.clipAction(clip);
  action.play();
  
  var v1 = -359;
  var v2 = 536;
  for(let i=0;i<25;i++){
      //const vehicleM = new THREE.Mesh()
      const vehicle = new YUKA.Vehicle();
      const path = new YUKA.Path();
      const fishClone = SkeletonUtils.clone(model);
      
      fishClone.position.z = 100;
      fishClone.matrixAutoUpdate = false;

      scene.add(fishClone);
      fishes.add(fishClone);
      
      document.addEventListener('click', onMouseClick, false);

      function onMouseClick(event){
          const mouse = new THREE.Vector2();
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
        // Raycasting to check if the mouse click intersects with the cube
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);
          
          intersects = raycaster.intersectObject(fishClone);
  
          if (intersects.length > 0){
            fishCollectionCount += 1;
            fishc_s = String(fishCollectionCount);
            scene.remove(fishClone);
            displayRandomPopup("You catched ".concat(fishc_s, " fish"), 'popup', 'popupText', 5000);              
          }
  
      }

      vehicle.setRenderComponent(fishClone,sync);
      
      vehicle.position.x = Math.random()* v1 + v2;
      vehicle.position.z = -Math.random()* v1 - v2;
      if (i%2==0){
        var x = 2.5 * Math.random() * -5;
        var z = 2.5 - Math.random() * 150;
      }
      else{
        var x = 2.5 - Math.random() * 25;
        var z = 2.5 * Math.random() * 250;

      }
      
      for (let j = 0; j<9; j++){

        path.add( new YUKA.Vector3(x, -4, z));
        x+=Math.random() * Math.random();
        z+=12;
        path.add( new YUKA.Vector3(x, -4, z));
        x+=2;
        z+=22;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=2;
        z+=32;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=2;
        z+=42;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=2;
        z+=52;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=2;
        z+=-2;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=2;
        z+=-20;

        path.add( new YUKA.Vector3(x, -4, z));
        if (i%2 == 0){
          x+=z * x + Math.random();
          z-=x * z - Math.random() + 240;
        }
        else{
          x-=z -Math.random() * x;
          z+=x + Math.random() * z + 150;
        }


      }
      
      path.loop = true;

  
    vehicle.position.copy(path.current());
  
    vehicle.maxspeed = 5;
  
    const followPathBehavior = new YUKA.FollowPathBehavior(path, 0.5);
    vehicle.steering.add(followPathBehavior);
  
    const onPathBehavior = new YUKA.OnPathBehavior(path, 0.5);
    onPathBehavior.radius = 2;
    vehicle.steering.add(onPathBehavior);
  
    entityManager.add(vehicle);
    
    
  
  }
  
  var v1 = -4670;
  var v2 = 7006;
  for(let i=0;i<15;i++){
      
      const vehicle = new YUKA.Vehicle();
      const path = new YUKA.Path();
      const fishClone = SkeletonUtils.clone(model);
      fishClone.position.z = 150;
      fishClone.matrixAutoUpdate = false;
      // fishClone.position.x = Math.random()*5;
      fishClone.position.z = Math.random()*5;
      scene.add(fishClone);
      fishes.add(fishClone);
      document.addEventListener('click', onMouseClick, false);

      function onMouseClick(event){
          const mouse = new THREE.Vector2();
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
        // Raycasting to check if the mouse click intersects with the cube
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);
          
          intersects = raycaster.intersectObject(fishClone);

          if (intersects.length > 0){
              fishCollectionCount += 1;
              fishc_s = String(fishCollectionCount);
              
              scene.remove(fishClone);
              displayRandomPopup("You catched ".concat(fishc_s, " fish"), 'popup', 'popupText', 5000);              
          }
  
      }
      
      vehicle.setRenderComponent(fishClone,sync);
      vehicle.position.x = Math.random()* v1 + v2;
      vehicle.position.z = -Math.random()* v1 - v2;
      if (i%2==0){
        var x = 2.5 + Math.random() * 15;
        var z = 2.5 - Math.random() * 230;
      }
      else{
        var x = 2.5 - Math.random() * 15;
        var z = 2.5 + Math.random() * 140;

      }
      
      for (let j = 0; j<9; j++){

        path.add( new YUKA.Vector3(x, -4, z));
        x+=4;
        z-=8;
        path.add( new YUKA.Vector3(x, -4, z));
        x+=10;
        z-=18;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=15;
        z-=28;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=20;
        z-=38;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=25;
        z-=48;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=30;
        z-=58;

        path.add( new YUKA.Vector3(x, -4, z));
        x+=35;
        z-=68;

        path.add( new YUKA.Vector3(x, -4, z));
        if (i%2 == 0){
          x+=z;
          z-=x;
        }
        else{
          x-=z * Math.random() + 200;
          z+=x * Math.random() + 23;
        }


      }
      
      path.loop = true;

  
    vehicle.position.copy(path.current());
  
    vehicle.maxspeed = 5;
  
    const followPathBehavior = new YUKA.FollowPathBehavior(path, 0.5);
    vehicle.steering.add(followPathBehavior);
  
    const onPathBehavior = new YUKA.OnPathBehavior(path, 0.5);
    onPathBehavior.radius = 2;
    vehicle.steering.add(onPathBehavior);
  
    entityManager.add(vehicle);
  
  }

-----------------------------------------------------------------------------------------------------------------------------
2 . Collision Detection
-----------------------------------------------------------------------------------------------------------------------------
// Cannon Physics world
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.81, 0)
});

// Island Body 
const islandBody = new CANNON.Body({
    mass: 0,
    shape: new CANNON.Box(new CANNON.Vec3(200,15,200)),
    position: new CANNON.Vec3(0, 2,465),
    material: islandPhysMat
});
world.addBody(islandBody);    

// Boat Body 
const boatBody = new CANNON.Body({
     mass: 1,
     shape: new CANNON.Box(new CANNON.Vec3(2,2,4)),
     position: new CANNON.Vec3(container.position.x, container.position.y, container.position.z),
     material: BoatPhysMat,   
 });

 world.addBody(boatBody);

// Shark Body 
const SharkPhysMat = new CANNON.Material();
    

const sharkBody = new CANNON.Body({
    mass: 1,
    shape: new CANNON.Box(new CANNON.Vec3(2,2,4)),
    position: new CANNON.Vec3(0,-2.5,-45),
    material: SharkPhysMat,
                 
});


sharkBody.velocity.set(0,0,0);
world.addBody(sharkBody);

function checkCollisions() {
    // Check collisions between box and sphere
    var contacts = world.contacts;
    // boatBody.applyEngineForce(1000,2);
    // console.log(contacts);
    for (var i = 0; i < contacts.length; i++) {
        var contact = contacts[i];
        if (
            (contact.bi === boatBody && contact.bj === islandBody) ||
            (contact.bi === islandBody && contact.bj === boatBody)
        ) {
            scene.remove(sharkModel);
            world.removeBody(sharkBody);
          
            reached_island_flag = 1;
            //console.log('collision detected...');
            collision_flag = 1;
            
       
            boatBody.velocity.set(0, 0, 0);

            // Move the boat slightly away from the island based on collision normal
            const collisionNormal = contact.ni.clone();
            const separationDistance = 0.1; // Adjust this value as needed
            boatBody.position.vadd(collisionNormal.scale(separationDistance), boatBody.position);
            movingForward = false;
           
          }
          else if (
            (contact.bi === sharkBody && contact.bj === boatBody) ||
            (contact.bi === boatBody && contact.bj === sharkBody)
        ) {
            // container.remove(c_model);
            // console.log("collision detected... ");
            attacked_flag = 1;
            let force = new CANNON.Vec3(-3, -0.1, -container.position.z);
            sharkBody.velocity.set(0, 0, 0);
        //     // Move the boat slightly away from the island based on collision normal
            const collisionNormal = contact.ni.clone();
            const separationDistance = 0.1; // Adjust this value as needed
            sharkBody.position.vadd(collisionNormal.scale(separationDistance), sharkBody.position);
            movingForward = false;
            // alert('You are been attacked by shark... ');
            world.removeBody(boatBody);
            // alert('You have lost the game... ');
           
          }
          
    }
   
}

const cannonDebugger = new CannonDebugger(scene, world);
-----------------------------------------------------------------------------------------------------------------------------
3 . Resume State
-----------------------------------------------------------------------------------------------------------------------------
export function container_position(container, camera, tempCameraVector, tempModelVector, xAxis, cameraOrigin){
    if (typeof (Storage) !== undefined){
  
      
      const positions = {
        x : container.position.x,
        y : container.position.y,
        z : container.position.z
      };
      const camera_position = {
        cam_x : camera.position.x,
        cam_y : camera.position.y,
        cam_z : camera.position.z,
      }
      const container_rotation = {
        rotate_x : container.rotation.x,
        rotate_y : container.rotation.y,
        rotate_z : container.rotation.z
      };
      sessionStorage.setItem('container', JSON.stringify(positions));
      sessionStorage.setItem('camera', JSON.stringify(camera_position));
      sessionStorage.setItem('container_rotationY', JSON.stringify(container_rotation));
    }  
    
    
  }
-----------------------------------------------------------------------------------------------------------------------------
import * as Island from './IslandLoad.js';
const cam_obj = JSON.parse(sessionStorage.getItem('camera'));
console.log(cam_obj);
Island.camera.position.set(
    cam_obj.cam_x,
    cam_obj.cam_y,
    cam_obj.cam_z
);

const obj = JSON.parse(sessionStorage.getItem('container'));

Island.container.position.set(
    obj.x,
    obj.y,
    obj.z
);

if (Island.container.position.x == 0 && Island.container.position.y == 0 && Island.container.position.z == 0){
    Island.callback();
    Island.camera.lookAt(Island.container.position);    
}
else{

	const container_rotation_Y  = JSON.parse(sessionStorage.getItem('container_rotationY'));

	Island.container.rotation.set(
    		container_rotation_Y.rotate_x,
    		container_rotation_Y.rotate_y,
    		container_rotation_Y.rotate_z
	);
	Island.container.rotateY(parseFloat(sessionStorage.getItem('model_rotate_w')));
	Island.water.material.uniforms[ 'time' ].value = 1.0 / 60.0;
	Island.camera.lookAt(Island.container.position);
	Island.callback();
}

-----------------------------------------------------------------------------------------------------------------------------
4 . Island
-----------------------------------------------------------------------------------------------------------------------------
let grass_z_position = 273,grass_x_position = -193;

    let stoneCollioderArr = [];
    const Stoneloader = new GLTFLoader();
    // const array_grass_stone = [];
    Stoneloader.load('model/rock1.glb', function (glb){
        const stonemodel = glb.scene;
        stonemodel.scale.set(4, 4, 4);
        stonemodel.position.set(10,4,275);
        // console.log(stonemodel.children[0]);
        for (let i = 0; i < 200; i++) {
          let j = parseInt(Math.random() * 6);
            const clonedModel = SkeletonUtils.clone(stonemodel.children[j]);
            // Set a unique name for each cloned grass model
            clonedModel.name = "Grass ".concat(String(i+1));
            clonedModel.scale.set(0.15,0.15,0.15);
            clonedModel.position.y = 3.8;
            clonedModel.position.z = grass_z_position + Math.random()*300;
            clonedModel.position.x = grass_x_position + Math.random()*300;
            const body = new CANNON.Body({ mass: 0 });
            body.addShape(new CANNON.Box(new CANNON.Vec3(2, 1, 1)));
            body.position.set(clonedModel.position.x, clonedModel.position.y, clonedModel.position.z);
            stoneCollioderArr.push(body);
            world.addBody(body);

            
            

            // // Store the cannon.js body in a property of the cloned model for later use
            clonedModel.cannonBody = body;

            scene.add(clonedModel);
        }
        
        for (let i = 200; i < 400; i++) {
          let j = parseInt(Math.random() * 6);
          // console.log(j)
            const clonedModel = SkeletonUtils.clone(stonemodel.children[j]);
            // Set a unique name for each cloned grass model
            clonedModel.name = "Grass ".concat(String(i+1));
            clonedModel.scale.set(0.15,0.15,0.15);
            clonedModel.position.y = 3.8;
            clonedModel.position.z = (271) + Math.random()*300;
            clonedModel.position.x = (193) - Math.random()*300;
            const body = new CANNON.Body({ mass: 0 });
            body.addShape(new CANNON.Box(new CANNON.Vec3(2, 1, 1)));
            body.position.set(clonedModel.position.x, clonedModel.position.y, clonedModel.position.z);
            stoneCollioderArr.push(body);
            world.addBody(body);

            // // Store the cannon.js body in a property of the cloned model for later use
            clonedModel.cannonBody = body;

            scene.add(clonedModel);
        }
        
      });
    
    const Grassloader = new GLTFLoader();
    
    Grassloader.load('model/grass.glb', function (glb){
        const grassmodel = glb.scene;
        grassmodel.scale.set(4, 4, 4);
        grassmodel.position.set(10,4,275);
        // console.log(grassmodel.children[0]);
        for (let i = 0; i < 300; i++) {
          let j = parseInt(Math.random() * 6);
          // console.log(j)
            const clonedModel = SkeletonUtils.clone(grassmodel.children[j]);
           
            clonedModel.name = "Grass ".concat(String(i+1));
            clonedModel.scale.set(0.1,0.1,0.1);
            clonedModel.position.y = 4;
            clonedModel.position.z = grass_z_position + Math.random()*300;
            clonedModel.position.x = grass_x_position + Math.random()*300;
            scene.add(clonedModel);
        }
        
        for (let i = 300; i < 600; i++) {
          let j = parseInt(Math.random() * 6);
          // console.log(j)
            const clonedModel = SkeletonUtils.clone(grassmodel.children[j]);
            // Set a unique name for each cloned grass model
            clonedModel.name = "Grass ".concat(String(i+1));
            clonedModel.scale.set(0.1,0.1,0.1);
            clonedModel.position.y = 3.8;
            clonedModel.position.z = (271) + Math.random()*300;
            clonedModel.position.x = (193) - Math.random()*300;
            scene.add(clonedModel);
        }

     });
    
    let TreesCollider1 = []
    const Treeloader = new GLTFLoader();
    
    Treeloader.load('model/trees1 (1).glb', function (glb){
        const treemodel = glb.scene;

        
        for (let i = 0; i < 100; i++) {
          let j = parseInt(Math.random()*20);
          const clonedModel = SkeletonUtils.clone(treemodel.children[j]);
          // console.log(clonedModel);
          // Set a unique name for each cloned tree model
          clonedModel.scale.set(0.8,1,0.8);
          clonedModel.name = "Tree ".concat(String(i+1));
          clonedModel.position.y = 5;
          clonedModel.position.z = grass_z_position + (Math.random()*350);
          clonedModel.position.x = grass_x_position + (Math.random()*300);
          const treesBody = new CANNON.Body({ mass: 0 });
          treesBody.addShape(new CANNON.Box(new CANNON.Vec3(2.5, 5, 2.5)));
          treesBody.position.set(clonedModel.position.x, clonedModel.position.y, clonedModel.position.z);
          TreesCollider1.push(treesBody);
          world.addBody(treesBody);
          clonedModel.cannonBody = treesBody;

          scene.add(clonedModel);
        }

        for (let i = 100; i < 200; i++) {
          let j = parseInt(Math.random() * 6);
          // console.log(j)
            const clonedModel = SkeletonUtils.clone(treemodel.children[j]);
            // Set a unique name for each cloned tree model
            clonedModel.name = "Grass ".concat(String(i+1));
            clonedModel.scale.set(0.8,1,0.8);
            clonedModel.position.y = 5;
            clonedModel.position.z = (271) + Math.random()*300;
            clonedModel.position.x = (193) - Math.random()*300;
            const treesBody = new CANNON.Body({ mass: 0 });
            treesBody.addShape(new CANNON.Box(new CANNON.Vec3(2.5, 5, 2.5)));
            treesBody.position.set(clonedModel.position.x, clonedModel.position.y, clonedModel.position.z);
            TreesCollider1.push(treesBody);
            world.addBody(treesBody);
            clonedModel.cannonBody = treesBody;
  
            scene.add(clonedModel);
        }
  });

  let TreesCollider2 = []
  const Treeloader2 = new GLTFLoader();
  Treeloader2.load('model/trees2 (1).glb', function (glb){
      const treemodel = glb.scene;
     
      for (let i = 200; i < 300; i++) {
        let j = parseInt(Math.random()*20);
        const clonedModel = SkeletonUtils.clone(treemodel.children[j]);
        // console.log(clonedModel);
        // Set a unique name for each cloned tree model
        clonedModel.scale.set(0.8,1,0.8);
        clonedModel.name = "Tree ".concat(String(i+1));
        clonedModel.position.y = 5;
        clonedModel.position.z = grass_z_position + (Math.random()*350);
        clonedModel.position.x = grass_x_position + (Math.random()*300);
        const treesBody2 = new CANNON.Body({ mass: 0 });
        treesBody2.addShape(new CANNON.Box(new CANNON.Vec3(2.5, 5, 2.5)));
        treesBody2.position.set(clonedModel.position.x, clonedModel.position.y, clonedModel.position.z);
        TreesCollider2.push(treesBody2);
        world.addBody(treesBody2);
        clonedModel.cannonBody = treesBody2;

        scene.add(clonedModel);
      }

      for (let i = 300; i < 400; i++) {
        let j = parseInt(Math.random()*20);
        const clonedModel = SkeletonUtils.clone(treemodel.children[j]);
        // console.log(clonedModel);
        // Set a unique name for each cloned tree model
        clonedModel.scale.set(0.8,1,0.8);
        clonedModel.name = "Tree ".concat(String(i+1));
        clonedModel.position.y = 5;
        clonedModel.position.z = (271) + (Math.random()*350);
        clonedModel.position.x = (193) - (Math.random()*300);
        const treesBody2 = new CANNON.Body({ mass: 0 });
        treesBody2.addShape(new CANNON.Box(new CANNON.Vec3(2.5, 5, 2.5)));
        treesBody2.position.set(clonedModel.position.x, clonedModel.position.y, clonedModel.position.z);
        TreesCollider2.push(treesBody2);
        world.addBody(treesBody2);
        clonedModel.cannonBody = treesBody2;

        scene.add(clonedModel);
     }
  });
-----------------------------------------------------------------------------------------------------------------------------
5 . Pop Up
-----------------------------------------------------------------------------------------------------------------------------
function displayRandomPopup(messages, popupId, popupTextId, displayTime) {
    // Get a random message
    // var randomIndex = Math.floor(Math.random() * messages.length);
    var popupText = messages;
    console.log(popupText);
    // Update the text content of the popup
    document.getElementById(popupTextId).textContent = popupText;
  
    // Display the popup
    document.getElementById(popupId).style.display = 'block';
  
    // Close the popup after a specified time
    setTimeout(function () {
      document.getElementById(popupId).style.display = 'none';
    }, displayTime);
  }
  
  // Example usage:
  var messages = 
    ' ';
 
  displayRandomPopup(messages, 'popup', 'popupText', 5000);
 
// Open and close the popup automatically
// openAndClosePopup();

export {displayRandomPopup}
-----------------------------------------------------------------------------------------------------------------------------
<style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      width: 100%;
      height: 100%;
      margin: 0;
    }

    .box-container {
      top: 0;
      position: relative;
      opacity: 0; /* Initial opacity for fade-in effect */
      animation: fadeIn 2s ease forwards; /* Animation for fade-in */
      z-index: 10;
    }

    #popup {
      position: absolute;
      left: 1100px;
      transform: translateX(-50%);
      bottom: 190px;
      width: 300px;
      height: 130px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: white;
      border-radius: 20px;
      animation: animateBox 4s linear forwards, fadeOut 2s 4s forwards; /* Added fadeOut animation */
      z-index: 10;
    }

    #popup::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(to right, transparent 0%, transparent 50%, black 50%, black 100%);
      background-size: 200% 100%;
      background-position: 100% 0;
      animation: animateBox 4s linear forwards;
      opacity: 0.5;
      border-radius: 20px;
    }

    #popup::after {
      content: '';
      position: absolute;
      inset: 5px;
      background-color: rgb(84, 242, 250);
      border-radius: 16px;
    }
    #popupText {
        top:50px;
  z-index: 100; /* Keep the z-index high to ensure it's on top */
  color: black;
  font-size: 16px;
  text-align: center;
  position: relative; /* Add position relative to establish stacking context */
}


    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
      }
    }

    @keyframes animateBox {
      0% {
        background-position: 100% 0;
      }
      100% {
        background-position: 0 100%;
      }
    }
  </style>
</head>
<body>
  <div class="box-container">
    <div id="popup">
      <div id="popupText">Welcome to game Stranded!!!</div>
    </div>
  </div>
  <script src="fishPickingUsingRod.js" type="module"></script>
</body>
-----------------------------------------------------------------------------------------------------------------------------
6 . Splash Screen
-----------------------------------------------------------------------------------------------------------------------------
<style>
        body {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #282c34;
            color: white;
            font-family: 'Arial', sans-serif;
            background-image: url("home_page1.jpeg");
             background-repeat: no-repeat;
            background-size: 1550px 870px;
          }

        .loading-container {
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #61dafb;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="loading-container">
        <div class="spinner"></div>
        <div class="loading-text">Loading...</div>
    </div>
    <script>
        setTimeout(() => {
            window.location.href = "./Survivaljs.html";
        } , 6000)
    </script>
</body>
-----------------------------------------------------------------------------------------------------------------------------
7 . Sun,Water and Camera
-----------------------------------------------------------------------------------------------------------------------------
export let  water, sun;
// Scene and renderer

export const scene = new THREE.Scene();
scene.background = new THREE.Color( 0xa0a0a0 );
scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );
export const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setPixelRatio( window.devicePixelRatio );
// renderer.outputEncoding = THREE.sRGBEncoding;
renderer.shadowMap.enabled = true;
document.body.appendChild( renderer.domElement );



// Lights
const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
hemiLight.position.set( 0, 20, 0 );
scene.add( hemiLight );

const dirLight = new THREE.DirectionalLight( 0xffffff );
dirLight.position.set( 3, 10, 10 );
dirLight.castShadow = true;
dirLight.shadow.camera.top = 2;
dirLight.shadow.camera.bottom = - 2;
dirLight.shadow.camera.left = - 2;
dirLight.shadow.camera.right = 2;
dirLight.shadow.camera.near = 0.1;
dirLight.shadow.camera.far = 40;
scene.add( dirLight );

sun = new THREE.Vector3();

    // Water

    const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );

    water = new Water(
        waterGeometry,
        {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load( './waternormals.jpg', function ( texture ) {

                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

            } ),
            sunDirection: new THREE.Vector3(),
            sunColor: 'YEllow',
            waterColor: '#09deed',
            distortionScale: 3.7,
            fog: scene.fog !== undefined
        }
    );


    water.rotation.x = - Math.PI / 2;

    scene.add( water );

    // Skybox

    const sky = new Sky();
    sky.scale.setScalar( 10000 );
    scene.add( sky );

    const skyUniforms = sky.material.uniforms;

    skyUniforms[ 'turbidity' ].value = 10;
    skyUniforms[ 'rayleigh' ].value = 2;
    skyUniforms[ 'mieCoefficient' ].value = 0.005;
    skyUniforms[ 'mieDirectionalG' ].value = 0.8;

    const parameters = {
        elevation: 10,
        azimuth: 180
    };

    const pmremGenerator = new THREE.PMREMGenerator( renderer );
    let renderTarget;

    function updateSun() {

        const phi = THREE.MathUtils.degToRad(90 - parameters.elevation );
        const theta = THREE.MathUtils.degToRad( parameters.azimuth );

        sun.setFromSphericalCoords( 2, phi, theta );

        sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
        water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();

        if ( renderTarget !== undefined ) renderTarget.dispose();

        renderTarget = pmremGenerator.fromScene( sky );

        scene.environment = renderTarget.texture;

    }

    updateSun();

// Container for both camera and person
export const container = new THREE.Group();
scene.add(container);

// Camera and controls
export const xAxis = new THREE.Vector3(1, 0, 0);
export const tempCameraVector = new THREE.Vector3();
export const tempModelVector = new THREE.Vector3();
const tempCameraVector2 = new THREE.Vector3();
export const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 1000 );
camera.position.set( 0, 2, -7 );
export const cameraOrigin = new THREE.Vector3(0, 1.5, 0);
camera.lookAt(cameraOrigin);
container.add(camera);
-----------------------------------------------------------------------------------------------------------------------------
8 . Model Loading ( Boat animation, Character animation )
-----------------------------------------------------------------------------------------------------------------------------
// Boat
let new_c_model;
let boatMixer;

const loader = new GLTFLoader();
loader.load( 'model/animatedBoat.glb', function ( glb ) {
  model = glb.scene;
  
  model.position.y = -0.4;
  const clips = glb.animations;
  boatMixer = new THREE.AnimationMixer(model);
  const clip = THREE.AnimationClip.findByName(clips,'boatAction');
  const action = boatMixer.clipAction(clip);
  action.play();
  model.traverse( function ( object ) { 
    if ( object.isMesh ) {
      object.castShadow = true;
      
    }   
  });
  container.add(model);
 });

export let c_model;
 let character_mixer;

 function characterLoading(x, y, z, y_rotate){

 
 const characterLoader = new GLTFLoader();
 characterLoader.load('model/animatingCharacter.glb', function (glb){
   c_model = glb.scene;
   c_model.scale.set(0.2,0.2,0.2);
   c_model.rotateY(y_rotate);
   c_model.position.y = -0.2;
   c_model.name = "characterModel";
   const charcterClips = glb.animations;
   character_mixer = new THREE.AnimationMixer(c_model);
   const c_clip = THREE.AnimationClip.findByName(charcterClips, 'boatIdle');
   const c_action = character_mixer.clipAction(c_clip);
   c_action.play();
   console.log(charcterClips);

   container.add(c_model);
 });
 }

export const animate = function () {
  
  requestAnimationFrame( animate ); 
  // cannonDebugger.update();
  const clockDelta = clock.getDelta();
  if (vehicle2 && path2){
    vehicle2.maxSpeed = 45;
    path2.loop = false;
  }
  world.step(timeStep);

  boatBody.position.y = 0.5;
  sharkBody.position.y = -2.5;
  sharkBody.position.x = container.position.x;

  if (barrel_pickup_flag){
    displayRandomPopup("Hurray!! you found a fishing Rod !! Start collecting fish",'popup', 'popupText', 5000); 
   
    
    
    const rodLoading = new GLTFLoader();
    
    rodLoading.load('model/animatingCharacter_2.glb', function (glb){

      new_c_model = glb.scene;
      new_c_model.scale.set(0.2,0.2,0.2);
      new_c_model.rotateY(0.1);
      new_c_model.position.y = -0.1;
      new_c_model.name = "characterModel";
      const charcterClips = glb.animations;
      console.log(charcterClips);
      character_mixer = new THREE.AnimationMixer(new_c_model);
      const c_clip = THREE.AnimationClip.findByName(charcterClips, "fishingRod");
      const c_action = character_mixer.clipAction(c_clip);
      c_action.play();
         
      container.remove(c_model);
      container.add(new_c_model);
   
    });
    barrel_pickup_flag = 0;
  }
 
       vehicle2.maxSpeed = 4;
       for (let j=0; j<70; j++){
           
         path2.add(new YUKA.Vector3(container.position.x, -2.5, z));
         z += 0.01;

       }

     vehicle2.position.copy(path2.current());
       
   // vehicle.maxspeed = 15;
 
   const followPathBehavior = new YUKA.FollowPathBehavior(path2, 0.5);
   vehicle2.steering.add(followPathBehavior);
 
   const onPathBehavior = new YUKA.OnPathBehavior(path2, 0.5);
   onPathBehavior.radius = 2;
   vehicle2.steering.add(onPathBehavior);
 
   entityManager.add(vehicle2);



    });


  }
  if(mixer){
      mixer.update(clockDelta);
  }
  if (mixer2){
      mixer2.update(clockDelta);
  }
  if (mixer3){
    mixer3.update(clockDelta);
  }
  if (boatMixer){
    boatMixer.update(clockDelta);
  }
  if (character_mixer){
    character_mixer.update(clockDelta);
  }
  if (sharkMixer){
    sharkMixer.update(clockDelta);
  }
  const delta = time.update().getDelta();
  entityManager.update(delta);
  if (sharkModel && container){
    sharkModel.position.x = container.position.x;
    z += 0.45;
    const s_clip = THREE.AnimationClip.findByName(s_clips,'bite');
    const s_action = sharkMixer.clipAction(s_clip);
    s_action.play();
    
    // console.log(vehicle.maxSpeed);
    path2.add(new YUKA.Vector3(0,-2.5,z));
    

    // sharkModel.position.copy(entityManager.entities[0].position);
    sharkModel.position.z = z;
    // console.log(sharkModel.position.z);
    sharkBody.position.z = sharkModel.position.z;
    
}

  if(movingForward) {
    // Get the X-Z plane in which camera is looking to move the player
    camera.getWorldDirection(tempCameraVector);
    const cameraDirection = tempCameraVector.setY(0).normalize();
    
    // // Get the X-Z plane in which player is looking to compare with camera
    model.getWorldDirection(tempModelVector);
    if (new_c_model){
      new_c_model.getWorldDirection(tempCameraVector2);  
    }
    else{

    
      c_model.getWorldDirection(tempCameraVector2);

    }
    const playerDirection = tempModelVector.setY(0).normalize();

    // // Get the angle to x-axis. z component is used to compare if the angle is clockwise or anticlockwise since angleTo returns a positive value
    const cameraAngle = cameraDirection.angleTo(xAxis) * (cameraDirection.z > 0 ? 1 : -1);
    const playerAngle = playerDirection.angleTo(xAxis) * (playerDirection.z > 0 ? 1 : -1);
    
    // // Get the angle to rotate the player to face the camera. Clockwise positive
    const angleToRotate = playerAngle - cameraAngle;
    
    // // Get the shortest angle from clockwise angle to ensure the player always rotates the shortest angle
    let sanitisedAngle = angleToRotate;
    
    if(angleToRotate > Math.PI) {
      sanitisedAngle = angleToRotate - 2 * Math.PI
    }
    if(angleToRotate < -Math.PI) {
      sanitisedAngle = angleToRotate + 2 * Math.PI
    }
    
    // Rotate the model by a tiny value towards the camera direction
    model.rotateY(
      Math.max(-0.05, Math.min(sanitisedAngle, 0.05))
    );
    if (new_c_model){
      new_c_model.rotateY(
        Math.max(-0.05, Math.min(sanitisedAngle, 0.05))  
    )
  
    }
    else{
      c_model.rotateY(
        Math.max(-0.05, Math.min(sanitisedAngle, 0.05))  
      )
    }
    sessionStorage.setItem('model_rotate_w', model.rotation.y);
    
    
    
    container.position.add(cameraDirection.multiplyScalar(0.5));    
    camera.lookAt(container.position.clone().add(cameraOrigin));
    boatBody.position.x = container.position.x;
    boatBody.position.y = container.position.y;
    boatBody.position.z = container.position.z;
  }
  else if (movingLeft){

    container.rotateY(0.02);
    boatBody.quaternion.copy(container.quaternion);
    sessionStorage.setItem('rotateY', '0.02');
    

  }
  else if (movingRight){

    container.rotateY(-0.02);
    boatBody.quaternion.copy(container.quaternion);
    sessionStorage.setItem('rotateYNeg', '-0.02');
    
  }
  else if (movingBackward){
    camera.getWorldDirection(tempCameraVector);
    const cameraDirection = tempCameraVector.setY(0).normalize();
    
    // // Get the X-Z plane in which player is looking to compare with camera
    model.getWorldDirection(tempModelVector);
    if (new_c_model){
      new_c_model.getWorldDirection(tempCameraVector2);  
    }
    else{

    
      c_model.getWorldDirection(tempCameraVector2);

    }

    const playerDirection = tempModelVector.setY(0).normalize();

    // // Get the angle to x-axis. z component is used to compare if the angle is clockwise or anticlockwise since angleTo returns a positive value
    const cameraAngle = cameraDirection.angleTo(xAxis) * (cameraDirection.z > 0 ? 1 : -1);
    const playerAngle = playerDirection.angleTo(xAxis) * (playerDirection.z > 0 ? 1 : -1);
    
    // // Get the angle to rotate the player to face the camera. Clockwise positive
    const angleToRotate = playerAngle - cameraAngle;
    
    // // Get the shortest angle from clockwise angle to ensure the player always rotates the shortest angle
    let sanitisedAngle = angleToRotate;
    
    if(angleToRotate > Math.PI) {
      sanitisedAngle = angleToRotate - 2 * Math.PI
    }
    if(angleToRotate < -Math.PI) {
      sanitisedAngle = angleToRotate + 2 * Math.PI
    }
    
    // Rotate the model by a tiny value towards the camera direction
    model.rotateY(
      Math.max(-0.05, Math.min(sanitisedAngle, 0.05))
    );
    if (new_c_model){
      new_c_model.rotateY(
        Math.max(-0.05, Math.min(sanitisedAngle, 0.05))  
    )
  
    }
    else{
      c_model.rotateY(
        Math.max(-0.05, Math.min(sanitisedAngle, 0.05))  
      )
    }
    sessionStorage.setItem('model_rotate_w', model.rotation.y);

    container.position.add(cameraDirection.multiplyScalar(-0.5));
    camera.lookAt(container.position.clone().add(cameraOrigin));
    boatBody.position.x = container.position.x;
    boatBody.position.y = container.position.y;
    boatBody.position.z = container.position.z;

  }
  groundMesh.position.copy(groundBody.position);
  groundMesh.quaternion.copy(groundBody.quaternion);
  if (island){
      island.position.copy(islandBody.position);
      island.quaternion.copy(islandBody.quaternion);

  }
  if (container){
      
      container.position.copy(boatBody.position);
      container.quaternion.copy(boatBody.quaternion);
  }
  
  // world.removeBody(islandBody);


  checkCollisions();

  if (attacked_flag){
      
      container.remove(c_model);
      world.removeBody(sharkBody);
      // alert('You are been attacked by shark... ');
      displayRandomPopup("You are been attacked by Shark !!",'popup', 'popupText', 5000);       
      scene.remove(sharkModel);

      movingForward = false;
      movingBackward = false;
      movingRight = false;
      movingLeft = false;
      attacked_flag = 0;
      setTimeout(()=>{
        window.location.href = './fishrodPicking.html';
      }, 2000);

      
      

  }
  if(reached_island_flag){
      // alert('You have been safely reached to the island... ');
      
      world.removeBody(boatBody);
      reached_island_flag = 0;
      window.location.href = "./SplashScreen.html";
  }  
  // console.log(container.rotation.x, container.rotation.y, container.rotation.z);
  water.material.uniforms[ 'time' ].value += 0.5 / 60.0;
  renderer.render( scene, camera );
};

animate();
-----------------------------------------------------------------------------------------------------------------------------
9 . Mini Games
-----------------------------------------------------------------------------------------------------------------------------
const levels = [
  { word: "algorithm", time: 10 },
  { word: "variable", time: 8 },
  { word: "database", time: 8 },
  { word: "function", time: 6 },
  { word: "framework", time: 6 },
  { word: "programming", time: 4 },
  { word: "interface", time: 3 },
  { word: "encryption", time: 3 },
  { word: "compiler", time: 2 },
  { word: "operatingsystem", time: 2 }
];

let currentLevel = 0;
let time = 10;
let timer;
let isGameRunning = false;

function startGame() {
  if (!isGameRunning) {
    isGameRunning = true;
    document.getElementById("result").innerText = "";
    document.getElementById("user-input").value = "";
    currentLevel = 0; // Reset to the beginning
    time = levels[currentLevel].time; // Set the initial time
    updateWord();
    updateTimer();
    document.getElementById("start-btn").style.display = "none";
    document.getElementById("reset-btn").style.display = "inline-block";

    timer = setInterval(() => {
      if (time > 0) {
        time--;
        updateTimer();
      } else {
        endGame();
      }
    }, 1000);
  }
}


function resetGame() {
  clearInterval(timer);
  isGameRunning = false;
  document.getElementById("start-btn").style.display = "inline-block";
  document.getElementById("reset-btn").style.display = "none";
  document.getElementById("result").innerText = "";
  document.getElementById("user-input").value = "";
  document.getElementById("word-display").innerText = ""; // Hide the word display
  currentLevel = 0;
  time = 10;
  updateWord();
  updateTimer();
}

function updateWord() {
  document.getElementById("word-display").innerText = levels[currentLevel].word;
}

function updateTimer() {
  document.getElementById("time").innerText = time;
}

function checkInput() {
  const userInput = document.getElementById("user-input").value.trim().toLowerCase();
  const currentWord = levels[currentLevel].word;
  if (userInput === currentWord) {
    currentLevel++;
    document.getElementById("user-input").value = "";
    if (currentLevel < levels.length) {
      updateWord();
      time = levels[currentLevel].time;
      updateTimer();
    } else {
      endGame();
    }
  }
}
function endGame() {
  clearInterval(timer);
  isGameRunning = false;
  document.getElementById("result").innerText = "Game Over!";
  document.getElementById("start-btn").style.display = "inline-block";
  document.getElementById("reset-btn").style.display = "none";
  // Stop any running animations
  document.getElementById("time").style.animation = "none";
  document.getElementById("time").style.opacity = 1;
  // Disable the user input field
  document.getElementById("user-input").disabled = true;
}
document.getElementById("user-input").addEventListener("input", checkInput);
-----------------------------------------------------------------------------------------------------------------------------
10 . Barrel Picking On Mouse Click/Replacing Model with Fishing Rod
-----------------------------------------------------------------------------------------------------------------------------
let barrel_z_position = 100;
let barrel_x_position = 10;
let clonedModel;
export let popped_barrels = [];
let barrel_pickup_flag = 0;

const barrelLoader = new GLTFLoader();

barrelLoader.load('model/barrel.glb', function (glb){
    const barrelmodel = glb.scene;
    barrelmodel.scale.set(.8, .8, .8);
    barrelmodel.rotation.set(1, 2, 0.6);

    for (let i = 0; i < 10; i++) {
        const clonedModel = SkeletonUtils.clone(barrelmodel);

        // Set a unique name for each cloned barrel model
        clonedModel.name = "barrel ".concat(String(i+1));
        
        clonedModel.position.z = barrel_z_position;
        clonedModel.position.x = barrel_x_position;
        scene.add(clonedModel);
        barrel_z_position += 30;
        if (i % 2 == 0) {
            barrel_x_position -= 30;
        } else {
            barrel_x_position += 30;
        }
        document.addEventListener('click', onMouseClick, false);
        
        function onMouseClick(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
          const mouse = new THREE.Vector2();
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Raycasting to check if the mouse click intersects with the cube
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);

          intersects = raycaster.intersectObject(clonedModel);

          if (intersects.length > 0) {
            // Remove the model
            if (clonedModel.name == 'barrel 1'){
              barrel_pickup_flag = 1;
            }
            displayRandomPopup("Barrel picked up !!!", 'popup', 'popupText', 5000);
            container_position(container, camera, tempCameraVector, tempModelVector, xAxis, cameraOrigin);
            scene.remove(clonedModel);
            
            popped_barrels.push(clonedModel);
            
            
            
          }
          else{
            barrel_r = false;
          }
        }

    }

});

 function onMouseClick(event){
          const mouse = new THREE.Vector2();
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
        // Raycasting to check if the mouse click intersects with the cube
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);
          
          intersects = raycaster.intersectObject(fishClone);
  
          if (intersects.length > 0){
            fishCollectionCount += 1;
            fishc_s = String(fishCollectionCount);
            scene.remove(fishClone);
            displayRandomPopup("You catched ".concat(fishc_s, " fish"), 'popup', 'popupText', 5000);              
          }
  
    }

-----------------------------------------------------------------------------------------------------------------------------
11 . Shark AI
-----------------------------------------------------------------------------------------------------------------------------
if (fishCollectionCount == 2){
    displayRandomPopup("Shark is coming behind go to island soon !!!",'popup', 'popupText', 5000);     
    container.remove(new_c_model);
    new_c_model = undefined;
    characterLoading(container.position.x, 0.5, container.position.z, 0.1);
    fishCollectionCount = -1;
    const SharkLoader = new GLTFLoader();
    SharkLoader.load('model/shark.glb', function (glb){
     sharkModel = glb.scene;
   //   sharkModel.matrixAutoUpdate = false;
     sharkModel.position.y = -2.5;
     sharkModel.position.z = -45;
     sharkModel.scale.set(0.8,0.8,0.8);
     s_clips = glb.animations;
     sharkMixer = new THREE.AnimationMixer(sharkModel);
   //   console.log(s_clips);
   //   const clips = ['swimming', 'bite'];
       
       const s_clip = THREE.AnimationClip.findByName(s_clips,'swimming');
       const s_action = sharkMixer.clipAction(s_clip);
       s_action.play();
 

   
     scene.add(sharkModel);
-----------------------------------------------------------------------------------------------------------------------------